{
  "run_id": "1764549253",
  "timestamp": "2025-12-01 02:34:13",
  "model": "groq/compound-mini",
  "total_prompts": 2,
  "prompts": [
    {
      "timestamp": "2025-12-01 02:33:29",
      "agent": "identification_agent",
      "model": "openai/gpt-oss-120b",
      "system_prompt": "### ROLE\nYou are a Senior Software Quality Assurance Engineer specializing in Python.\n\n### OBJECTIVE\nYour primary goal is to analyze the given Python codebase and identify a comprehensive list of test scenarios, including critical edge cases, for human approval.\n\n### RULES & CONSTRAINTS\n- Focus exclusively on identifying test scenarios; do not generate test code.\n- Prioritize critical paths, common use cases, and edge cases (e.g., invalid inputs, empty values, concurrency issues).\n- If the code is unclear or incomplete, identify the ambiguity as a test scenario.\n\n### OUTPUT FORMAT\n- Provide the response as a single JSON object.\n- The JSON object should contain one key, \"test_scenarios\", which holds a list of test case objects.\n- Each test case object must include:\n    - \"scenario_description\": A concise string explaining the test case.\n    - \"priority\": A string with a value of \"High\", \"Medium\", or \"Low\".\n\n### EXAMPLE\n```json\n{\n  \"test_scenarios\": [\n    {\n      \"scenario_description\": \"Test user login with valid credentials.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Test user login with an invalid password.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Test user login with an empty username field.\",\n      \"priority\": \"Medium\"\n    }\n  ]\n}\n```",
      "user_prompt": "Analyze this Python codebase and identify test scenarios.\n\nFiles: C:\\Users\\PC\\Desktop\\Expample Apps\\todo\\todo_app.py\n\nCode:\n# File: C:\\Users\\PC\\Desktop\\Expample Apps\\todo\\todo_app.py\nimport customtkinter as ctk\nimport json\nimport os\nfrom datetime import datetime\nfrom typing import List, Dict\n\n# Application Configuration\nctk.set_appearance_mode(\"dark\")\nctk.set_default_color_theme(\"blue\")\n\n\nclass Task:\n    \"\"\"Represents a single task\"\"\"\n\n    def __init__(self, title: str, completed: bool = False, created_at: str = None):\n        self.title = title\n        self.completed = completed\n        self.created_at = created_at or datetime.now().isoformat()\n\n    def to_dict(self) -> Dict:\n        return {\n            \"title\": self.title,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        return cls(data[\"title\"], data[\"completed\"], data.get(\"created_at\"))\n\n\nclass TaskWidget(ctk.CTkFrame):\n    \"\"\"Custom widget for displaying a task\"\"\"\n\n    def __init__(self, master, task: Task, on_toggle, on_delete, on_edit, **kwargs):\n        super().__init__(master, **kwargs)\n\n        self.task = task\n        self.on_toggle = on_toggle\n        self.on_delete = on_delete\n        self.on_edit = on_edit\n\n        self.configure(fg_color=(\"gray85\", \"gray20\"), corner_radius=10)\n\n        # Checkbox\n        self.checkbox = ctk.CTkCheckBox(\n            self,\n            text=\"\",\n            width=30,\n            command=self._toggle_task,\n            checkbox_width=22,\n            checkbox_height=22,\n        )\n        self.checkbox.grid(row=0, column=0, padx=(15, 10), pady=15, sticky=\"w\")\n\n        # Task label\n        self.label = ctk.CTkLabel(\n            self, text=task.title, font=ctk.CTkFont(size=14), anchor=\"w\"\n        )\n        self.label.grid(row=0, column=1, padx=5, pady=15, sticky=\"ew\")\n        self.label.bind(\"<Double-Button-1>\", lambda e: self._edit_task())\n\n        # Delete button\n        self.delete_btn = ctk.CTkButton(\n            self,\n            text=\"\u2715\",\n            width=35,\n            height=35,\n            font=ctk.CTkFont(size=18, weight=\"bold\"),\n            fg_color=\"transparent\",\n            hover_color=(\"gray75\", \"gray30\"),\n            text_color=(\"gray40\", \"gray60\"),\n            command=self._delete_task,\n        )\n        self.delete_btn.grid(row=0, column=2, padx=(5, 15), pady=15)\n\n        # Configure grid\n        self.grid_columnconfigure(1, weight=1)\n\n        self._update_appearance()\n\n    def _update_appearance(self):\n        \"\"\"Update the appearance based on completion status\"\"\"\n        if self.task.completed:\n            self.checkbox.select()\n            self.label.configure(\n                text_color=(\"gray50\", \"gray55\"),\n                font=ctk.CTkFont(size=14, overstrike=True),\n            )\n        else:\n            self.checkbox.deselect()\n            self.label.configure(\n                text_color=(\"gray10\", \"gray90\"),\n                font=ctk.CTkFont(size=14, overstrike=False),\n            )\n\n    def _toggle_task(self):\n        self.task.completed = not self.task.completed\n        self._update_appearance()\n        self.on_toggle()\n\n    def _delete_task(self):\n        self.on_delete(self.task)\n\n    def _edit_task(self):\n        self.on_edit(self.task)\n\n    def update_task(self, task: Task):\n        \"\"\"Update the widget with new task data\"\"\"\n        self.task = task\n        self.label.configure(text=task.title)\n        self._update_appearance()\n\n\nclass TodoApp(ctk.CTk):\n    \"\"\"Main To-Do Application\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Window setup\n        self.title(\"To-Do App\")\n        self.geometry(\"600x750\")\n        self.minsize(500, 600)\n\n        # Data\n        self.tasks: List[Task] = []\n        self.filter_mode = \"all\"  # all, active, completed\n        self.data_file = \"tasks.json\"\n\n        # Load saved tasks\n        self.load_tasks()\n\n        # Build UI\n        self.create_widgets()\n        self.refresh_task_list()\n\n        # Protocol for closing\n        self.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n\n    def create_widgets(self):\n        \"\"\"Create all UI widgets\"\"\"\n\n        # Configure grid\n        self.grid_columnconfigure(0, weight=1)\n        self.grid_rowconfigure(2, weight=1)\n\n        # ===== HEADER =====\n        header_frame = ctk.CTkFrame(self, fg_color=\"transparent\")\n        header_frame.grid(row=0, column=0, padx=20, pady=(20, 10), sticky=\"ew\")\n        header_frame.grid_columnconfigure(0, weight=1)\n\n        # Title\n        title_label = ctk.CTkLabel(\n            header_frame, text=\"\ud83d\udcdd My Tasks\", font=ctk.CTkFont(size=32, weight=\"bold\")\n        )\n        title_label.grid(row=0, column=0, sticky=\"w\")\n\n        # Theme toggle\n        self.theme_switch = ctk.CTkSwitch(\n            header_frame,\n            text=\"\ud83c\udf19\",\n            font=ctk.CTkFont(size=20),\n            command=self.toggle_theme,\n            width=60,\n        )\n        self.theme_switch.grid(row=0, column=1, padx=10)\n\n        # Stats\n        self.stats_label = ctk.CTkLabel(\n            header_frame,\n            text=\"0 tasks\",\n            font=ctk.CTkFont(size=13),\n            text_color=(\"gray50\", \"gray60\"),\n        )\n        self.stats_label.grid(row=1, column=0, sticky=\"w\", pady=(5, 0))\n\n        # ===== INPUT SECTION =====\n        input_frame = ctk.CTkFrame(self, fg_color=\"transparent\")\n        input_frame.grid(row=1, column=0, padx=20, pady=10, sticky=\"ew\")\n        input_frame.grid_columnconfigure(0, weight=1)\n\n        # Task entry\n        self.task_entry = ctk.CTkEntry(\n            input_frame,\n            placeholder_text=\"Add a new task...\",\n            height=45,\n            font=ctk.CTkFont(size=14),\n            border_width=2,\n        )\n        self.task_entry.grid(row=0, column=0, padx=(0, 10), sticky=\"ew\")\n        self.task_entry.bind(\"<Return>\", lambda e: self.add_task())\n\n        # Add button\n        self.add_btn = ctk.CTkButton(\n            input_frame,\n            text=\"Add\",\n            width=80,\n            height=45,\n            font=ctk.CTkFont(size=14, weight=\"bold\"),\n            command=self.add_task,\n        )\n        self.add_btn.grid(row=0, column=1)\n\n        # ===== FILTER SECTION =====\n        filter_frame = ctk.CTkFrame(self, fg_color=\"transparent\")\n        filter_frame.grid(row=2, column=0, padx=20, pady=(0, 10), sticky=\"ew\")\n\n        # Filter buttons\n        self.filter_all_btn = ctk.CTkButton(\n            filter_frame,\n            text=\"All\",\n            width=80,\n            height=32,\n            command=lambda: self.set_filter(\"all\"),\n            fg_color=(\"gray70\", \"gray30\"),\n        )\n        self.filter_all_btn.grid(row=0, column=0, padx=(0, 5))\n\n        self.filter_active_btn = ctk.CTkButton(\n            filter_frame,\n            text=\"Active\",\n            width=80,\n            height=32,\n            command=lambda: self.set_filter(\"active\"),\n            fg_color=\"transparent\",\n            border_width=2,\n        )\n        self.filter_active_btn.grid(row=0, column=1, padx=5)\n\n        self.filter_completed_btn = ctk.CTkButton(\n            filter_frame,\n            text=\"Completed\",\n            width=80,\n            height=32,\n            command=lambda: self.set_filter(\"completed\"),\n            fg_color=\"transparent\",\n            border_width=2,\n        )\n        self.filter_completed_btn.grid(row=0, column=2, padx=5)\n\n        # Clear completed button\n        self.clear_btn = ctk.CTkButton(\n            filter_frame,\n            text=\"Clear Completed\",\n            width=120,\n            height=32,\n            command=self.clear_completed,\n            fg_color=\"transparent\",\n            border_width=2,\n            text_color=(\"red\", \"lightcoral\"),\n        )\n        self.clear_btn.grid(row=0, column=3, padx=(20, 0))\n\n        # ===== TASK LIST =====\n        self.scrollable_frame = ctk.CTkScrollableFrame(\n            self,\n            fg_color=\"transparent\",\n            scrollbar_button_color=(\"gray70\", \"gray30\"),\n            scrollbar_button_hover_color=(\"gray60\", \"gray40\"),\n        )\n        self.scrollable_frame.grid(\n            row=3, column=0, padx=20, pady=(0, 20), sticky=\"nsew\"\n        )\n        self.scrollable_frame.grid_columnconfigure(0, weight=1)\n\n    def add_task(self):\n        \"\"\"Add a new task\"\"\"\n        title = self.task_entry.get().strip()\n        if not title:\n            return\n\n        task = Task(title)\n        self.tasks.append(task)\n        self.task_entry.delete(0, \"end\")\n        self.save_tasks()\n        self.refresh_task_list()\n\n    def edit_task(self, task: Task):\n        \"\"\"Edit an existing task\"\"\"\n        dialog = ctk.CTkInputDialog(text=f\"Edit task:\", title=\"Edit Task\")\n        dialog._entry.insert(0, task.title)\n        new_title = dialog.get_input()\n\n        if new_title and new_title.strip():\n            task.title = new_title.strip()\n            self.save_tasks()\n            self.refresh_task_list()\n\n    def delete_task(self, task: Task):\n        \"\"\"Delete a task\"\"\"\n        self.tasks.remove(task)\n        self.save_tasks()\n        self.refresh_task_list()\n\n    def toggle_task(self):\n        \"\"\"Task completion toggled\"\"\"\n        self.save_tasks()\n        self.update_stats()\n\n    def set_filter(self, mode: str):\n        \"\"\"Set the filter mode and update UI\"\"\"\n        self.filter_mode = mode\n\n        # Update button appearance\n        buttons = {\n            \"all\": self.filter_all_btn,\n            \"active\": self.filter_active_btn,\n            \"completed\": self.filter_completed_btn,\n        }\n\n        for btn_mode, btn in buttons.items():\n            if btn_mode == mode:\n                btn.configure(fg_color=(\"gray70\", \"gray30\"), border_width=0)\n            else:\n                btn.configure(fg_color=\"transparent\", border_width=2)\n\n        self.refresh_task_list()\n\n    def clear_completed(self):\n        \"\"\"Remove all completed tasks\"\"\"\n        self.tasks = [task for task in self.tasks if not task.completed]\n        self.save_tasks()\n        self.refresh_task_list()\n\n    def refresh_task_list(self):\n        \"\"\"Refresh the displayed task list\"\"\"\n        # Clear existing widgets\n        for widget in self.scrollable_frame.winfo_children():\n            widget.destroy()\n\n        # Filter tasks\n        filtered_tasks = self.get_filtered_tasks()\n\n        # Create widgets for filtered tasks\n        for i, task in enumerate(filtered_tasks):\n            task_widget = TaskWidget(\n                self.scrollable_frame,\n                task,\n                on_toggle=self.toggle_task,\n                on_delete=self.delete_task,\n                on_edit=self.edit_task,\n            )\n            task_widget.grid(row=i, column=0, padx=0, pady=5, sticky=\"ew\")\n\n        # Show empty state if no tasks\n        if not filtered_tasks:\n            empty_label = ctk.CTkLabel(\n                self.scrollable_frame,\n                text=\"No tasks to show\"\n                if self.tasks\n                else \"Add your first task to get started! \u2728\",\n                font=ctk.CTkFont(size=14),\n                text_color=(\"gray50\", \"gray60\"),\n            )\n            empty_label.grid(row=0, column=0, pady=50)\n\n        self.update_stats()\n\n    def get_filtered_tasks(self) -> List[Task]:\n        \"\"\"Get tasks based on current filter\"\"\"\n        if self.filter_mode == \"active\":\n            return [task for task in self.tasks if not task.completed]\n        elif self.filter_mode == \"completed\":\n            return [task for task in self.tasks if task.completed]\n        else:  # all\n            return self.tasks\n\n    def update_stats(self):\n        \"\"\"Update the statistics display\"\"\"\n        total = len(self.tasks)\n        completed = sum(1 for task in self.tasks if task.completed)\n        active = total - completed\n\n        if total == 0:\n            stats_text = \"No tasks\"\n        else:\n            stats_text = f\"{total} task{'s' if total != 1 else ''} \u2022 {active} active \u2022 {completed} completed\"\n\n        self.stats_label.configure(text=stats_text)\n\n    def toggle_theme(self):\n        \"\"\"Toggle between dark and light mode\"\"\"\n        current_mode = ctk.get_appearance_mode()\n        new_mode = \"light\" if current_mode.lower() == \"dark\" else \"dark\"\n        ctk.set_appearance_mode(new_mode)\n\n        # Update switch emoji\n        self.theme_switch.configure(text=\"\u2600\ufe0f\" if new_mode == \"light\" else \"\ud83c\udf19\")\n\n    def save_tasks(self):\n        \"\"\"Save tasks to JSON file\"\"\"\n        data = {\n            \"tasks\": [task.to_dict() for task in self.tasks],\n            \"theme\": ctk.get_appearance_mode(),\n        }\n        with open(self.data_file, \"w\") as f:\n            json.dump(data, f, indent=2)\n\n    def load_tasks(self):\n        \"\"\"Load tasks from JSON file\"\"\"\n        if os.path.exists(self.data_file):\n            try:\n                with open(self.data_file, \"r\") as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task.from_dict(task_data) for task_data in data.get(\"tasks\", [])\n                    ]\n\n                    # Restore theme\n                    saved_theme = data.get(\"theme\", \"dark\")\n                    ctk.set_appearance_mode(saved_theme)\n            except Exception as e:\n                print(f\"Error loading tasks: {e}\")\n                self.tasks = []\n\n    def on_closing(self):\n        \"\"\"Handle application closing\"\"\"\n        self.save_tasks()\n        self.destroy()\n\n\ndef main():\n    \"\"\"Main entry point\"\"\"\n    app = TodoApp()\n    app.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()\n\n\nRespond with JSON containing test_scenarios.",
      "response": "{\n  \"test_scenarios\": [\n    {\n      \"scenario_description\": \"Add a new task with a valid non\u2011empty title and verify it appears in the list, is saved to tasks.json, and stats are updated.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Attempt to add a task with an empty string (or only whitespace) and verify that no task is created and UI remains unchanged.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Toggle the completion checkbox of a task and verify the task's completed flag flips, the visual style (overstrike, color) updates, and the change is persisted to disk.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Delete a task using the delete button and verify the task is removed from the UI, the internal list, and the JSON file.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Edit an existing task with a new valid title via the edit dialog and verify the title updates in the UI, the underlying Task object, and the saved file.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Attempt to edit a task and submit an empty or whitespace\u2011only title; verify the original title is retained and no error occurs.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Switch the theme using the theme toggle switch and verify the appearance mode changes (dark \u2194 light) and the switch emoji updates accordingly.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Close the application, reopen it, and verify that previously saved tasks and the selected theme are correctly loaded from tasks.json.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Set filter to 'Active' and verify only non\u2011completed tasks are displayed; then set to 'Completed' and verify only completed tasks are shown; finally set to 'All' and verify all tasks appear.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Press 'Clear Completed' when there are completed tasks and verify they are removed from the UI, internal list, and persisted file.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Load tasks when tasks.json is missing; verify the app starts with an empty task list without crashing.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Load tasks when tasks.json contains malformed JSON; verify the error is caught, an empty task list is used, and the app continues running.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Save tasks when the directory is read\u2011only or the file cannot be written; verify that an exception is handled gracefully and the user is not left with lost data.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Add a task with a very long title (e.g., 500 characters) and verify UI truncates or wraps appropriately without breaking layout.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Add a task containing special Unicode characters, emojis, and line breaks; verify they are stored and displayed correctly.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Rapidly add multiple tasks (e.g., 20) and then delete them in quick succession to test UI stability and memory handling.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Edit a task while the current filter hides it (e.g., edit an active task while filter is set to 'Completed') and verify the edit still updates the underlying data and appears correctly when filter changes.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Toggle a task's completion status while the filter is set to 'Active' or 'Completed' and verify the task moves to the appropriate filtered view instantly.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Attempt to delete a task that has already been removed (e.g., double\u2011click delete) and verify no unhandled exception occurs.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Run two instances of the application simultaneously, modify tasks in one instance, close it, then open the second instance and verify that the latest saved state is loaded (testing possible race conditions).\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Verify that the statistics label correctly reflects 0 tasks, 1 task, and pluralization (e.g., '1 task \u2022 1 active \u2022 0 completed' vs '2 tasks \u2022 2 active \u2022 0 completed').\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Check that the placeholder text in the task entry field disappears when the user starts typing and reappears when the field is cleared.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Hover over the delete button and verify the hover color changes as defined.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Resize the main window to its minimum size and verify that all UI elements remain accessible and correctly aligned.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Press the Return key while the task entry field is focused and verify it triggers the same behavior as clicking the 'Add' button.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Double\u2011click a task label to open the edit dialog and verify the dialog pre\u2011populates with the current title.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Verify that the scrollable task list correctly displays a vertical scrollbar when the number of tasks exceeds the visible area.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Check that the empty\u2011state message changes appropriately: 'No tasks to show' when filters hide all tasks, and 'Add your first task...' when there are no tasks at all.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Simulate a failure in json.dump (e.g., by mocking open to raise IOError) during save_tasks and verify the exception is caught without crashing the app.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Validate that the Task.from_dict class method correctly handles missing optional fields (e.g., created_at) without raising KeyError.\",\n      \"priority\": \"Medium\"\n    }\n  ]\n}",
      "is_mock": false
    },
    {
      "timestamp": "2025-12-01 02:33:45",
      "agent": "implementation_agent",
      "model": "groq/compound-mini",
      "system_prompt": "### ROLE\nYou are a Senior Software Development Engineer in Test (SDET) specializing in Python and the PyTest framework.\n\n### OBJECTIVE\nYour goal is to generate executable PyTest test scripts based on an approved JSON list of test scenarios.\n\n### CRITICAL RULES\n- Return ONLY raw Python code - NO markdown formatting, NO code fences (``` or ```python)\n- The output must be valid Python that can be saved directly to a .py file\n- Use the PyTest framework for all generated tests\n- Write clean, readable, and maintainable code following PEP 8 standards\n- Ensure each test function is self-contained and starts with 'test_'\n- Include all necessary imports at the top of the file\n\n### CRITICAL: CODE COVERAGE REQUIREMENTS\n- For coverage to be measured, you MUST import and use the source code DIRECTLY in the test process\n- DO NOT run source files as subprocesses for testing - pytest-cov cannot measure subprocess coverage\n- IMPORT the source module and test its functions, classes, and behavior directly\n- Use mocking to isolate side effects (e.g., network, file I/O)\n- Example for testing a server module:\n  ```python\n  import sys\n  from pathlib import Path\n\n  # Add project root to path for imports\n  PROJECT_ROOT = Path(__file__).parent.parent\n  sys.path.insert(0, str(PROJECT_ROOT))\n\n  # Now import the source module directly\n  import server  # This will be measured by coverage\n\n  def test_handler_class():\n      # Test the Handler class directly\n      assert hasattr(server, 'Handler')\n      assert issubclass(server.Handler, http.server.SimpleHTTPRequestHandler)\n  ```\n\n### CRITICAL: TESTING `if __name__ == \"__main__\":` BLOCKS\n- Code inside `if __name__ == \"__main__\":` is NOT executed when importing the module\n- To test this code, use `exec()` or `runpy.run_path()` with mocks\n- IMPORTANT: When using runpy.run_path() to test server code, you MUST mock:\n  1. `socketserver.TCPServer` to prevent real server startup\n  2. The serve_forever() method to avoid blocking\n  3. Have the mock raise KeyboardInterrupt to simulate shutdown\n- Example pattern:\n  ```python\n  from unittest.mock import patch, MagicMock\n  import runpy\n\n  def test_main_block_starts_server():\n      # MUST mock TCPServer to prevent real server from starting!\n      mock_httpd = MagicMock()\n      mock_httpd.serve_forever.side_effect = KeyboardInterrupt()  # Simulate Ctrl+C\n\n      mock_context = MagicMock()\n      mock_context.__enter__.return_value = mock_httpd\n      mock_context.__exit__.return_value = None\n\n      with patch('socketserver.TCPServer', return_value=mock_context):\n          with patch('os.path.exists', return_value=True):\n              runpy.run_path(str(SERVER_SCRIPT), run_name=\"__main__\")\n\n  def test_main_block_with_missing_directory():\n      with patch('os.path.exists', return_value=False):\n          with patch('builtins.exit') as mock_exit:\n              with patch('builtins.print'):\n                  try:\n                      runpy.run_path(str(SERVER_SCRIPT), run_name=\"__main__\")\n                  except SystemExit:\n                      pass\n              mock_exit.assert_called_once_with(1)\n  ```\n\n### CRITICAL: TESTING http.server.SimpleHTTPRequestHandler SUBCLASSES\n- These handlers require real socket connections to initialize\n- NEVER call Handler(None, None, None) - it will fail\n- Use mocking or test the class attributes instead:\n  ```python\n  def test_handler_inheritance():\n      assert issubclass(server.Handler, http.server.SimpleHTTPRequestHandler)\n\n  def test_handler_init_sets_directory():\n      # Check __init__ method signature or use runpy to run server\n      import inspect\n      sig = inspect.signature(server.Handler.__init__)\n      # Verify it accepts the expected parameters\n  ```\n\n### IMPORTANT: FILE PATH HANDLING\n- The test file will be saved in a `tests/` subdirectory of the project\n- Add the project root to sys.path to enable imports: `sys.path.insert(0, str(PROJECT_ROOT))`\n- Then import source modules directly: `import mymodule`\n- For file path references, use: `Path(__file__).parent.parent / \"filename.py\"`\n\n### IMPORTANT: WINDOWS COMPATIBILITY\n- NEVER use `signal.SIGINT` to stop processes - it is NOT supported on Windows\n- To stop a subprocess, use `proc.terminate()` or `proc.kill()` instead\n- For tests that need to simulate keyboard interrupt, mock the behavior instead of sending signals\n\n### OUTPUT FORMAT\n- Return raw Python code only - no explanations, no markdown\n- The code must be syntactically correct and ready for execution\n- Function names should clearly reflect the scenario (e.g., `test_login_with_invalid_password`)\n\n### EXAMPLE OUTPUT (note: no code fences, just raw Python):\nimport pytest\nimport sys\nimport runpy\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\n# Add project root to path for imports\nPROJECT_ROOT = Path(__file__).parent.parent\nsys.path.insert(0, str(PROJECT_ROOT))\nSERVER_SCRIPT = PROJECT_ROOT / \"server.py\"\n\n# Import source module directly (for coverage measurement)\nimport server\n\ndef test_handler_class_exists():\n    assert hasattr(server, 'Handler')\n\ndef test_port_constant():\n    assert server.PORT == 8000\n\ndef test_directory_constant():\n    assert server.DIRECTORY == 'dist'\n\ndef test_handler_inheritance():\n    import http.server\n    assert issubclass(server.Handler, http.server.SimpleHTTPRequestHandler)\n\ndef test_main_exits_when_directory_missing():\n    with patch('os.path.exists', return_value=False):\n        with patch('builtins.exit') as mock_exit:\n            with patch('builtins.print'):\n                try:\n                    runpy.run_path(str(SERVER_SCRIPT), run_name=\"__main__\")\n                except SystemExit:\n                    pass\n            mock_exit.assert_called_once_with(1)",
      "user_prompt": "Generate PyTest tests for these scenarios:\n\n{\n  \"test_scenarios\": [\n    {\n      \"scenario_description\": \"Add a new task with a valid non\\u2011empty title and verify it appears in the list, is saved to tasks.json, and stats are updated.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Attempt to add a task with an empty string (or only whitespace) and verify that no task is created and UI remains unchanged.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Toggle the completion checkbox of a task and verify the task's completed flag flips, the visual style (overstrike, color) updates, and the change is persisted to disk.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Delete a task using the delete button and verify the task is removed from the UI, the internal list, and the JSON file.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Edit an existing task with a new valid title via the edit dialog and verify the title updates in the UI, the underlying Task object, and the saved file.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Attempt to edit a task and submit an empty or whitespace\\u2011only title; verify the original title is retained and no error occurs.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Switch the theme using the theme toggle switch and verify the appearance mode changes (dark \\u2194 light) and the switch emoji updates accordingly.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Close the application, reopen it, and verify that previously saved tasks and the selected theme are correctly loaded from tasks.json.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Set filter to 'Active' and verify only non\\u2011completed tasks are displayed; then set to 'Completed' and verify only completed tasks are shown; finally set to 'All' and verify all tasks appear.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Press 'Clear Completed' when there are completed tasks and verify they are removed from the UI, internal list, and persisted file.\",\n      \"priority\": \"High\"\n    },\n    {\n      \"scenario_description\": \"Load tasks when tasks.json is missing; verify the app starts with an empty task list without crashing.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Load tasks when tasks.json contains malformed JSON; verify the error is caught, an empty task list is used, and the app continues running.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Save tasks when the directory is read\\u2011only or the file cannot be written; verify that an exception is handled gracefully and the user is not left with lost data.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Add a task with a very long title (e.g., 500 characters) and verify UI truncates or wraps appropriately without breaking layout.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Add a task containing special Unicode characters, emojis, and line breaks; verify they are stored and displayed correctly.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Rapidly add multiple tasks (e.g., 20) and then delete them in quick succession to test UI stability and memory handling.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Edit a task while the current filter hides it (e.g., edit an active task while filter is set to 'Completed') and verify the edit still updates the underlying data and appears correctly when filter changes.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Toggle a task's completion status while the filter is set to 'Active' or 'Completed' and verify the task moves to the appropriate filtered view instantly.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Attempt to delete a task that has already been removed (e.g., double\\u2011click delete) and verify no unhandled exception occurs.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Run two instances of the application simultaneously, modify tasks in one instance, close it, then open the second instance and verify that the latest saved state is loaded (testing possible race conditions).\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Verify that the statistics label correctly reflects 0 tasks, 1 task, and pluralization (e.g., '1 task \\u2022 1 active \\u2022 0 completed' vs '2 tasks \\u2022 2 active \\u2022 0 completed').\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Check that the placeholder text in the task entry field disappears when the user starts typing and reappears when the field is cleared.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Hover over the delete button and verify the hover color changes as defined.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Resize the main window to its minimum size and verify that all UI elements remain accessible and correctly aligned.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Press the Return key while the task entry field is focused and verify it triggers the same behavior as clicking the 'Add' button.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Double\\u2011click a task label to open the edit dialog and verify the dialog pre\\u2011populates with the current title.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Verify that the scrollable task list correctly displays a vertical scrollbar when the number of tasks exceeds the visible area.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Check that the empty\\u2011state message changes appropriately: 'No tasks to show' when filters hide all tasks, and 'Add your first task...' when there are no tasks at all.\",\n      \"priority\": \"Low\"\n    },\n    {\n      \"scenario_description\": \"Simulate a failure in json.dump (e.g., by mocking open to raise IOError) during save_tasks and verify the exception is caught without crashing the app.\",\n      \"priority\": \"Medium\"\n    },\n    {\n      \"scenario_description\": \"Validate that the Task.from_dict class method correctly handles missing optional fields (e.g., created_at) without raising KeyError.\",\n      \"priority\": \"Medium\"\n    }\n  ]\n}\n\nPROJECT STRUCTURE:\n- Tests will be saved to: tests/test_generated_*.py\n- Source files are in the project root:\n  - todo_app.py\n\nCRITICAL: CODE COVERAGE - IMPORT SOURCE FILES DIRECTLY:\n- Add project root to sys.path: `sys.path.insert(0, str(PROJECT_ROOT))`\n- Import source modules directly: `import server` (NOT as subprocess)\n- Test functions, classes, and constants directly to measure coverage\n- DO NOT run source files as subprocesses - coverage won't be measured!\n\nWINDOWS COMPATIBILITY:\n- NEVER use `signal.SIGINT` to stop processes (not supported on Windows)\n- Use `proc.terminate()` or `proc.kill()` to stop subprocesses\n- For keyboard interrupt tests, mock the behavior instead of sending real signals\n\nSource code:\n# File: C:\\Users\\PC\\Desktop\\Expample Apps\\todo\\todo_app.py\nimport customtkinter as ctk\nimport json\nimport os\nfrom datetime import datetime\nfrom typing import List, Dict\n\n# Application Configuration\nctk.set_appearance_mode(\"dark\")\nctk.set_default_color_theme(\"blue\")\n\n\nclass Task:\n    \"\"\"Represents a single task\"\"\"\n\n    def __init__(self, title: str, completed: bool = False, created_at: str = None):\n        self.title = title\n        self.completed = completed\n        self.created_at = created_at or datetime.now().isoformat()\n\n    def to_dict(self) -> Dict:\n        return {\n            \"title\": self.title,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        return cls(data[\"title\"], data[\"completed\"], data.get(\"created_at\"))\n\n\nclass TaskWidget(ctk.CTkFrame):\n    \"\"\"Custom widget for displaying a task\"\"\"\n\n    def __init__(self, master, task: Task, on_toggle, on_delete, on_edit, **kwargs):\n        super().__init__(master, **kwargs)\n\n        self.task = task\n        self.on_toggle = on_toggle\n        self.on_delete = on_delete\n        self.on_edit = on_edit\n\n        self.configure(fg_color=(\"gray85\", \"gray20\"), corner_radius=10)\n\n        # Checkbox\n        self.checkbox = ctk.CTkCheckBox(\n            self,\n            text=\"\",\n            width=30,\n            command=self._toggle_task,\n            checkbox_width=22,\n            checkbox_height=22,\n        )\n        self.checkbox.grid(row=0, column=0, padx=(15, 10), pady=15, sticky=\"w\")\n\n        # Task label\n        self.label = ctk.CTkLabel(\n            self, text=task.title, font=ctk.CTkFont(size=14), anchor=\"w\"\n        )\n        self.label.grid(row=0, column=1, padx=5, pady=15, sticky=\"ew\")\n        self.label.bind(\"<Double-Button-1>\", lambda e: self._edit_task())\n\n        # Delete button\n        self.delete_btn = ctk.CTkButton(\n            self,\n            text=\"\u2715\",\n            width=35,\n            height=35,\n            font=ctk.CTkFont(size=18, weight=\"bold\"),\n            fg_color=\"transparent\",\n            hover_color=(\"gray75\", \"gray30\"),\n            text_color=(\"gray40\", \"gray60\"),\n            command=self._delete_task,\n        )\n        self.delete_btn.grid(row=0, column=2, padx=(5, 15), pady=15)\n\n        # Configure grid\n        self.grid_columnconfigure(1, weight=1)\n\n        self._update_appearance()\n\n    def _update_appearance(self):\n        \"\"\"Update the appearance based on completion status\"\"\"\n        if self.task.completed:\n            self.checkbox.select()\n            self.label.configure(\n                text_color=(\"gray50\", \"gray55\"),\n                font=ctk.CTkFont(size=14, overstrike=True),\n            )\n        else:\n            self.checkbox.deselect()\n            self.label.configure(\n                text_color=(\"gray10\", \"gray90\"),\n                font=ctk.CTkFont(size=14, overstrike=False),\n            )\n\n    def _toggle_task(self):\n        self.task.completed = not self.task.completed\n        self._update_appearance()\n        self.on_toggle()\n\n    def _delete_task(self):\n        self.on_delete(self.task)\n\n    def _edit_task(self):\n        self.on_edit(self.task)\n\n    def update_task(self, task: Task):\n        \"\"\"Update the widget with new task data\"\"\"\n        self.task = task\n        self.label.configure(text=task.title)\n        self._update_appearance()\n\n\nclass TodoApp(ctk.CTk):\n    \"\"\"Main To-Do Application\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Window setup\n        self.title(\"To-Do App\")\n        self.geometry(\"600x750\")\n        self.minsize(500, 600)\n\n        # Data\n        self.tasks: List[Task] = []\n        self.filter_mode = \"all\"  # all, active, completed\n        self.data_file = \"tasks.json\"\n\n        # Load saved tasks\n        self.load_tasks()\n\n        # Build UI\n        self.create_widgets()\n        self.refresh_task_list()\n\n        # Protocol for closing\n        self.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n\n    def create_widgets(self):\n        \"\"\"Create all UI widgets\"\"\"\n\n        # Configure grid\n        self.grid_columnconfigure(0, weight=1)\n        self.grid_rowconfigure(2, weight=1)\n\n        # ===== HEADER =====\n        header_frame = ctk.CTkFrame(self, fg_color=\"transparent\")\n        header_frame.grid(row=0, column=0, padx=20, pady=(20, 10), sticky=\"ew\")\n        header_frame.grid_columnconfigure(0, weight=1)\n\n        # Title\n        title_label = ctk.CTkLabel(\n            header_frame, text=\"\ud83d\udcdd My Tasks\", font=ctk.CTkFont(size=32, weight=\"bold\")\n        )\n        title_label.grid(row=0, column=0, sticky=\"w\")\n\n        # Theme toggle\n        self.theme_switch = ctk.CTkSwitch(\n            header_frame,\n            text=\"\ud83c\udf19\",\n            font=ctk.CTkFont(size=20),\n            command=self.toggle_theme,\n            width=60,\n        )\n        self.theme_switch.grid(row=0, column=1, padx=10)\n\n        # Stats\n        self.stats_label = ctk.CTkLabel(\n            header_frame,\n            text=\"0 tasks\",\n            font=ctk.CTkFont(size=13),\n            text_color=(\"gray50\", \"gray60\"),\n        )\n        self.stats_label.grid(row=1, column=0, sticky=\"w\", pady=(5, 0))\n\n        # ===== INPUT SECTION =====\n        input_frame = ctk.CTkFrame(self, fg_color=\"transparent\")\n        input_frame.grid(row=1, column=0, padx=20, pady=10, sticky=\"ew\")\n        input_frame.grid_columnconfigure(0, weight=1)\n\n        # Task entry\n        self.task_entry = ctk.CTkEntry(\n            input_frame,\n            placeholder_text=\"Add a new task...\",\n            height=45,\n            font=ctk.CTkFont(size=14),\n            border_width=2,\n        )\n        self.task_entry.grid(row=0, column=0, padx=(0, 10), sticky=\"ew\")\n        self.task_entry.bind(\"<Return>\", lambda e: self.add_task())\n\n        # Add button\n        self.add_btn = ctk.CTkButton(\n            input_frame,\n            text=\"Add\",\n            width=80,\n            height=45,\n            font=ctk.CTkFont(size=14, weight=\"bold\"),\n            command=self.add_task,\n        )\n        self.add_btn.grid(row=0, column=1)\n\n        # ===== FILTER SECTION =====\n        filter_frame = ctk.CTkFrame(self, fg_color=\"transparent\")\n        filter_frame.grid(row=2, column=0, padx=20, pady=(0, 10), sticky=\"ew\")\n\n        # Filter buttons\n        self.filter_all_btn = ctk.CTkButton(\n            filter_frame,\n            text=\"All\",\n            width=80,\n            height=32,\n            command=lambda: self.set_filter(\"all\"),\n            fg_color=(\"gray70\", \"gray30\"),\n        )\n        self.filter_all_btn.grid(row=0, column=0, padx=(0, 5))\n\n        self.filter_active_btn = ctk.CTkButton(\n            filter_frame,\n            text=\"Active\",\n            width=80,\n            height=32,\n            command=lambda: self.set_filter(\"active\"),\n            fg_color=\"transparent\",\n            border_width=2,\n        )\n        self.filter_active_btn.grid(row=0, column=1, padx=5)\n\n        self.filter_completed_btn = ctk.CTkButton(\n            filter_frame,\n            text=\"Completed\",\n            width=80,\n            height=32,\n            command=lambda: self.set_filter(\"completed\"),\n            fg_color=\"transparent\",\n            border_width=2,\n        )\n        self.filter_completed_btn.grid(row=0, column=2, padx=5)\n\n        # Clear completed button\n        self.clear_btn = ctk.CTkButton(\n            filter_frame,\n            text=\"Clear Completed\",\n            width=120,\n            height=32,\n            command=self.clear_completed,\n            fg_color=\"transparent\",\n            border_width=2,\n            text_color=(\"red\", \"lightcoral\"),\n        )\n        self.clear_btn.grid(row=0, column=3, padx=(20, 0))\n\n        # ===== TASK LIST =====\n        self.scrollable_frame = ctk.CTkScrollableFrame(\n            self,\n            fg_color=\"transparent\",\n            scrollbar_button_color=(\"gray70\", \"gray30\"),\n            scrollbar_button_hover_color=(\"gray60\", \"gray40\"),\n        )\n        self.scrollable_frame.grid(\n            row=3, column=0, padx=20, pady=(0, 20), sticky=\"nsew\"\n        )\n        self.scrollable_frame.grid_columnconfigure(0, weight=1)\n\n    def add_task(self):\n        \"\"\"Add a new task\"\"\"\n        title = self.task_entry.get().strip()\n        if not title:\n            return\n\n        task = Task(title)\n        self.tasks.append(task)\n        self.task_entry.delete(0, \"end\")\n        self.save_tasks()\n        self.refresh_task_list()\n\n    def edit_task(self, task: Task):\n        \"\"\"Edit an existing task\"\"\"\n        dialog = ctk.CTkInputDialog(text=f\"Edit task:\", title=\"Edit Task\")\n        dialog._entry.insert(0, task.title)\n        new_title = dialog.get_input()\n\n        if new_title and new_title.strip():\n            task.title = new_title.strip()\n            self.save_tasks()\n            self.refresh_task_list()\n\n    def delete_task(self, task: Task):\n        \"\"\"Delete a task\"\"\"\n        self.tasks.remove(task)\n        self.save_tasks()\n        self.refresh_task_list()\n\n    def toggle_task(self):\n        \"\"\"Task completion toggled\"\"\"\n        self.save_tasks()\n        self.update_stats()\n\n    def set_filter(self, mode: str):\n        \"\"\"Set the filter mode and update UI\"\"\"\n        self.filter_mode = mode\n\n        # Update button appearance\n        buttons = {\n            \"all\": self.filter_all_btn,\n            \"active\": self.filter_active_btn,\n            \"completed\": self.filter_completed_btn,\n        }\n\n        for btn_mode, btn in buttons.items():\n            if btn_mode == mode:\n                btn.configure(fg_color=(\"gray70\", \"gray30\"), border_width=0)\n            else:\n                btn.configure(fg_color=\"transparent\", border_width=2)\n\n        self.refresh_task_list()\n\n    def clear_completed(self):\n        \"\"\"Remove all completed tasks\"\"\"\n        self.tasks = [task for task in self.tasks if not task.completed]\n        self.save_tasks()\n        self.refresh_task_list()\n\n    def refresh_task_list(self):\n        \"\"\"Refresh the displayed task list\"\"\"\n        # Clear existing widgets\n        for widget in self.scrollable_frame.winfo_children():\n            widget.destroy()\n\n        # Filter tasks\n        filtered_tasks = self.get_filtered_tasks()\n\n        # Create widgets for filtered tasks\n        for i, task in enumerate(filtered_tasks):\n            task_widget = TaskWidget(\n                self.scrollable_frame,\n                task,\n                on_toggle=self.toggle_task,\n                on_delete=self.delete_task,\n                on_edit=self.edit_task,\n            )\n            task_widget.grid(row=i, column=0, padx=0, pady=5, sticky=\"ew\")\n\n        # Show empty state if no tasks\n        if not filtered_tasks:\n            empty_label = ctk.CTkLabel(\n                self.scrollable_frame,\n                text=\"No tasks to show\"\n                if self.tasks\n                else \"Add your first task to get started! \u2728\",\n                font=ctk.CTkFont(size=14),\n                text_color=(\"gray50\", \"gray60\"),\n            )\n            empty_label.grid(row=0, column=0, pady=50)\n\n        self.update_stats()\n\n    def get_filtered_tasks(self) -> List[Task]:\n        \"\"\"Get tasks based on current filter\"\"\"\n        if self.filter_mode == \"active\":\n            return [task for task in self.tasks if not task.completed]\n        elif self.filter_mode == \"completed\":\n            return [task for task in self.tasks if task.completed]\n        else:  # all\n            return self.tasks\n\n    def update_stats(self):\n        \"\"\"Update the statistics display\"\"\"\n        total = len(self.tasks)\n        completed = sum(1 for task in self.tasks if task.completed)\n        active = total - completed\n\n        if total == 0:\n            stats_text = \"No tasks\"\n        else:\n            stats_text = f\"{total} task{'s' if total != 1 else ''} \u2022 {active} active \u2022 {completed} completed\"\n\n        self.stats_label.configure(text=stats_text)\n\n    def toggle_theme(self):\n        \"\"\"Toggle between dark and light mode\"\"\"\n        current_mode = ctk.get_appearance_mode()\n        new_mode = \"light\" if current_mode.lower() == \"dark\" else \"dark\"\n        ctk.set_appearance_mode(new_mode)\n\n        # Update switch emoji\n        self.theme_switch.configure(text=\"\u2600\ufe0f\" if new_mode == \"light\" else \"\ud83c\udf19\")\n\n    def save_tasks(self):\n        \"\"\"Save tasks to JSON file\"\"\"\n        data = {\n            \"tasks\": [task.to_dict() for task in self.tasks],\n            \"theme\": ctk.get_appearance_mode(),\n        }\n        with open(self.data_file, \"w\") as f:\n            json.dump(data, f, indent=2)\n\n    def load_tasks(self):\n        \"\"\"Load tasks from JSON file\"\"\"\n        if os.path.exists(self.data_file):\n            try:\n                with open(self.data_file, \"r\") as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task.from_dict(task_data) for task_data in data.get(\"tasks\", [])\n                    ]\n\n                    # Restore theme\n                    saved_theme = data.get(\"theme\", \"dark\")\n                    ctk.set_appearance_mode(saved_theme)\n            except Exception as e:\n                print(f\"Error loading tasks: {e}\")\n                self.tasks = []\n\n    def on_closing(self):\n        \"\"\"Handle application closing\"\"\"\n        self.save_tasks()\n        self.destroy()\n\n\ndef main():\n    \"\"\"Main entry point\"\"\"\n    app = TodoApp()\n    app.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()\n\n\nIMPORTANT RULES:\n1. Return ONLY valid Python code - no markdown, no code fences\n2. Include all necessary imports at the top\n3. Each test function must start with 'test_'\n4. IMPORT source modules directly for coverage (add project root to sys.path first)\n5. Use mocking for side effects (network, file I/O)\n6. Use proc.terminate() instead of signal.SIGINT for stopping processes\n\nGenerate a complete, executable PyTest file.",
      "response": "import sys\nimport json\nimport os\nfrom pathlib import Path\nfrom unittest.mock import MagicMock, patch, mock_open\n\nimport pytest\n\n# ---------- Mock customtkinter ----------\nclass _DummyWidget:\n    def __init__(self, *args, **kwargs):\n        self._config = {}\n        self._children = []\n\n    def grid(self, *args, **kwargs):\n        pass\n\n    def configure(self, **kwargs):\n        self._config.update(kwargs)\n\n    def bind(self, *args, **kwargs):\n        pass\n\n    def destroy(self):\n        pass\n\n    def winfo_children(self):\n        return self._children\n\n    def grid_columnconfigure(self, *args, **kwargs):\n        pass\n\nclass CTk(_DummyWidget):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.title_text = \"\"\n        self.geometry_text = \"\"\n        self._protocols = {}\n\n    def title(self, text):\n        self.title_text = text\n\n    def geometry(self, text):\n        self.geometry_text = text\n\n    def minsize(self, w, h):\n        pass\n\n    def protocol(self, name, func):\n        self._protocols[name] = func\n\n    def mainloop(self):\n        pass\n\n    def destroy(self):\n        pass\n\nclass CTkFrame(_DummyWidget):\n    pass\n\nclass CTkLabel(_DummyWidget):\n    def __init__(self, master=None, text=\"\", **kwargs):\n        super().__init__(master, **kwargs)\n        self.text = text\n\nclass CTkButton(_DummyWidget):\n    def __init__(self, master=None, command=None, **kwargs):\n        super().__init__(master, **kwargs)\n        self.command = command\n\nclass CTkCheckBox(_DummyWidget):\n    def __init__(self, master=None, command=None, **kwargs):\n        super().__init__(master, **kwargs)\n        self.command = command\n        self._selected = False\n\n    def select(self):\n        self._selected = True\n\n    def deselect(self):\n        self._selected = False\n\nclass CTkEntry(_DummyWidget):\n    def __init__(self, master=None, placeholder_text=\"\", **kwargs):\n        super().__init__(master, **kwargs)\n        self._value = \"\"\n        self.placeholder = placeholder_text\n\n    def get(self):\n        return self._value\n\n    def delete(self, start, end):\n        self._value = \"\"\n\n    def insert(self, index, text):\n        self._value = text\n\n    def bind(self, event, func):\n        pass\n\nclass CTkSwitch(_DummyWidget):\n    def __init__(self, master=None, command=None, **kwargs):\n        super().__init__(master, **kwargs)\n        self.command = command\n\nclass CTkScrollableFrame(_DummyWidget):\n    pass\n\nclass CTkFont:\n    def __init__(self, size=10, **kwargs):\n        self.size = size\n\ndef set_appearance_mode(mode):\n    set_appearance_mode.current = mode\n\ndef get_appearance_mode():\n    return getattr(set_appearance_mode, \"current\", \"dark\")\n\ndef set_default_color_theme(theme):\n    pass\n\nclass CTkInputDialog:\n    # Simple mock dialog; test will patch get_input\n    def __init__(self, text=\"\", title=\"\"):\n        self._entry = MagicMock()\n        self._entry.insert = MagicMock()\n\n    def get_input(self):\n        return None\n\n# Insert mock module into sys.modules before importing todo_app\nmock_ctk = MagicMock()\nmock_ctk.CTk = CTk\nmock_ctk.CTkFrame = CTkFrame\nmock_ctk.CTkLabel = CTkLabel\nmock_ctk.CTkButton = CTkButton\nmock_ctk.CTkCheckBox = CTkCheckBox\nmock_ctk.CTkEntry = CTkEntry\nmock_ctk.CTkSwitch = CTkSwitch\nmock_ctk.CTkScrollableFrame = CTkScrollableFrame\nmock_ctk.CTkFont = CTkFont\nmock_ctk.set_appearance_mode = set_appearance_mode\nmock_ctk.get_appearance_mode = get_appearance_mode\nmock_ctk.set_default_color_theme = set_default_color_theme\nmock_ctk.CTkInputDialog = CTkInputDialog\n\nsys.modules[\"customtkinter\"] = mock_ctk\n\n# Now import the source module\nPROJECT_ROOT = Path(__file__).parent.parent\nsys.path.insert(0, str(PROJECT_ROOT))\nimport todo_app\n\n# ---------- Fixtures ----------\n@pytest.fixture\ndef app(tmp_path):\n    \"\"\"Create a TodoApp instance with a temporary data file.\"\"\"\n    # Ensure a fresh data file path\n    data_file = tmp_path / \"tasks.json\"\n    with patch.object(todo_app.TodoApp, \"data_file\", str(data_file)):\n        # Patch save_tasks to avoid actual file I/O unless explicitly tested\n        with patch.object(todo_app.TodoApp, \"save_tasks\", MagicMock()) as mock_save:\n            instance = todo_app.TodoApp()\n            yield instance\n            # Cleanup\n            instance.destroy()\n\n# ---------- Helper ----------\ndef write_json(path, data):\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=2)\n\n# ---------- Tests ----------\ndef test_add_valid_task(app):\n    app.task_entry.insert(0, \"Buy milk\")\n    app.add_task()\n    assert len(app.tasks) == 1\n    assert app.tasks[0].title == \"Buy milk\"\n    # Entry should be cleared\n    assert app.task_entry.get() == \"\"\n    # Stats label should reflect one task\n    assert \"1 task\" in app.stats_label._config.get(\"text\", \"\")\n\ndef test_add_empty_task_is_ignored(app):\n    app.task_entry.insert(0, \"   \")\n    app.add_task()\n    assert len(app.tasks) == 0\n    # No change to stats\n    assert \"0 tasks\" in app.stats_label._config.get(\"text\", \"\")\n\ndef test_toggle_task_completion_updates_state_and_stats(app):\n    # Add a task first\n    app.task_entry.insert(0, \"Read book\")\n    app.add_task()\n    task = app.tasks[0]\n    assert not task.completed\n\n    # Simulate toggle via the widget's callback\n    # The widget is created during refresh; retrieve it\n    widget = app.scrollable_frame.winfo_children()[0]\n    widget._toggle_task()  # flips completed and calls app.toggle_task()\n    assert task.completed\n    # Stats should now show 0 active, 1 completed\n    stats = app.stats_label._config.get(\"text\", \"\")\n    assert \"0 active\" in stats and \"1 completed\" in stats\n\ndef test_delete_task_removes_it(app):\n    app.task_entry.insert(0, \"Task to delete\")\n    app.add_task()\n    assert len(app.tasks) == 1\n    task = app.tasks[0]\n\n    # Retrieve widget and invoke delete\n    widget = app.scrollable_frame.winfo_children()[0]\n    widget._delete_task()\n    assert len(app.tasks) == 0\n    # Stats should reflect no tasks\n    assert \"No tasks\" in app.stats_label._config.get(\"text\", \"\")\n\ndef test_edit_task_with_valid_title(app):\n    app.task_entry.insert(0, \"Old title\")\n    app.add_task()\n    task = app.tasks[0]\n\n    # Patch the input dialog to return a new title\n    with patch.object(todo_app, \"ctk\"):\n        with patch.object(todo_app.ctk, \"CTkInputDialog\") as mock_dialog_cls:\n            mock_dialog = MagicMock()\n            mock_dialog.get_input.return_value = \"New title\"\n            mock_dialog_cls.return_value = mock_dialog\n\n            app.edit_task(task)\n\n    assert task.title == \"New title\"\n    # Verify stats unchanged but UI refreshed (widget text updated)\n    widget = app.scrollable_frame.winfo_children()[0]\n    assert widget.label.text == \"New title\"\n\ndef test_edit_task_with_empty_title_keeps_original(app):\n    app.task_entry.insert(0, \"Stay same\")\n    app.add_task()\n    task = app.tasks[0]\n\n    with patch.object(todo_app, \"ctk\"):\n        with patch.object(todo_app.ctk, \"CTkInputDialog\") as mock_dialog_cls:\n            mock_dialog = MagicMock()\n            mock_dialog.get_input.return_value = \"   \"  # whitespace only\n            mock_dialog_cls.return_value = mock_dialog\n\n            app.edit_task(task)\n\n    assert task.title == \"Stay same\"\n    widget = app.scrollable_frame.winfo_children()[0]\n    assert widget.label.text == \"Stay same\"\n\ndef test_theme_toggle_switches_appearance_and_emoji(app):\n    # Initial mode is dark per set_appearance_mode default\n    assert todo_app.ctk.get_appearance_mode() == \"dark\"\n    app.toggle_theme()\n    assert todo_app.ctk.get_appearance_mode() == \"light\"\n    assert app.theme_switch._config.get(\"text\") == \"\u2600\ufe0f\"\n    # Toggle back\n    app.toggle_theme()\n    assert todo_app.ctk.get_appearance_mode() == \"dark\"\n    assert app.theme_switch._config.get(\"text\") == \"\ud83c\udf19\"\n\ndef test_load_tasks_missing_file_starts_empty(app):\n    # Ensure the data file does not exist\n    with patch(\"os.path.exists\", return_value=False):\n        app.load_tasks()\n    assert app.tasks == []\n    assert \"No tasks\" in app.stats_label._config.get(\"text\", \"\")\n\ndef test_load_tasks_malformed_json_results_in_empty_list(app):\n    malformed = \"{ this is not json\"\n    with patch(\"os.path.exists\", return_value=True), \\\n         patch(\"builtins.open\", mock_open(read_data=malformed)), \\\n         patch(\"json.load\", side_effect=json.JSONDecodeError(\"msg\", \"doc\", 0)):\n        app.load_tasks()\n    assert app.tasks == []\n    assert \"No tasks\" in app.stats_label._config.get(\"text\", \"\")\n\ndef test_clear_completed_removes_only_completed(app):\n    # Add two tasks, one completed\n    app.task_entry.insert(0, \"Active task\")\n    app.add_task()\n    app.task_entry",
      "is_mock": false
    }
  ]
}